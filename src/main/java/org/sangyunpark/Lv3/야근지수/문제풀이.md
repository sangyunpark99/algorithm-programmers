이 문제의 핵심은 작업량을 가능한 한 균등하게 분배해야 피로도(제곱 합)가 최소화된다는 점이다.
이를 위해 매번 가장 작업량이 큰 일을 1씩 줄이는 방식이 최적의 방법이다.
최댓값을 반복적으로 효율적으로 얻기 위해 우선순위 큐를 사용했다.
poll()과 offer() 연산만 사용하므로 remove() 연산으로 인한 추가 오버헤드가 없고, 따라서 TreeMap 대신 PriorityQueue가 적절하다. 
전체 시간 복잡도는 O(nlogn) 이므로, n=20,000일때 충분히 통과 가능하다.